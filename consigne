###################### CONSIGNE ###############################

* Un philosophe minimum
* Manger , dormir , penser => que un a la fois
* Autant de fourchettes que de philosophe 
* Il mange avec la fourchette a sa droite et a sa gauche
* Apres manger : dodo
* Apres dodo : penser
=> La simulation prends faim quand l'un meurt de faim, tout les philo doivent manger
* Les philosophes ne communiquent pas et ne savent pas si l'un est en train de mourir

### Consignes ###

* Pas de variables globales
* Arguments a prendre : 
	1) number_of_philosophers => du coup aussi le nombre de fourchette
	2) time_to_die => Si un philosophe n'a pas mange avec la fin de time_to_die (en ms) => Depuis son dernier repas OU le debut
	3) time_to_eat => Le temps qu'il prends a manger(donc avoir les 2 fourchettes
	4) time_to_sleep => Le temps de dodo
	OPTION = 5) number_of_times_each_philosopher_must_eat = La simulation prnds fin si tout le monde a manger autant, sinon mort

* Chaque philo est un nombre entre 1 et number_of_philo
* Le 1 est assis a cote du N, chaque philo est entre N-1 et N+1
* Tout changement d'etat doit etre formatte avec (temps en ms) (Nbr du philo) (action)
* Pas de melange de message
* Pas plus de 10ms entre la mort et le message annoncant sa mort

### fonctions ###

Fct autorises :
	memset : void *memset(void *str, int c, size_t n) Remplis n espace memoire de *str avec unsigned char de c

	printf 
	malloc
	free
	write

	usleep : stop le threads pendant x ms

	gettimeofday : time.h = sert a lire l'heure

	pthread_create : cree un nouveau threads
		* Pour cela il faut creer un variable pthread_t;
		* Pthread_create(&newthread, NULL, fonction avec un arg *void, NULL);
		* Le dernier arg de la fonction est l'argument que lon veut passer a la fonction *void, du coup a typecast apres
		* On peut aussi passer un pointeur qu'ont peu malloc dans le thread pour recup la valeur apres
	pthread_join : Sert a lier les threads, qui va attendre que l'autre fini;
			Pthread_join(&newthread, NULL); 
	pthread_mutex_init : mutex = mutual exclusion , il faut creer une viarable pthread_mutex_t
	pthread_mutex_destroy :
	pthread_mutex_lock : pthread_mutex_lock(&nomdelavariable) action puis unlock
	pthread_mutex_unlock :

* 1 Philo = 1 Threads
* Une fourchette entre chaque paire de philosophe, 1 philosophe = 1 fourchette = mort ?
* Proteger fourchette avec mutex entre chacune d'elle

### Bonus ###
 Ca a l'air trop vnr.

#######
